---
layout: post
title: Destructuring in Clojure
tags: [pl, clojure]
---
<div id="outline-container-org1e0abe2" class="outline-2">
<h2 id="org1e0abe2"><span class="section-number-2">1.</span> Reference</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li><a href="http://clojure.org/special_forms#Special%20Forms--Binding%20Forms%20%28Destructuring%29">http://clojure.org/special_forms#Special%20Forms--Binding%20Forms%20%28Destructuring%29</a></li>
<li><a href="http://blog.jayfields.com/2010/07/clojure-destructuring.html">http://blog.jayfields.com/2010/07/clojure-destructuring.html</a></li>
</ol>
</div>
</div>
<div id="outline-container-orga03cb66" class="outline-2">
<h2 id="orga03cb66"><span class="section-number-2">2.</span> What is Destructuring?</h2>
<div class="outline-text-2" id="text-2">
<p>
One of Speical Froms in clojure.
Kind of Syntactic sugar?
</p>
<blockquote>
<p>
Clojure supports abstract structural binding, often called destructuring, in let binding lists, fn parameter lists, and any macro that expands into a let or fn. The basic idea is that a binding-form can be a data structure literal containing symbols that get bound to the respective parts of the init-expr. The binding is abstract in that a vector literal can bind to anything that is sequential, while a map literal can bind to anything that is associative.
</p>
</blockquote>
</div>
<div id="outline-container-org9117389" class="outline-3">
<h3 id="org9117389"><span class="section-number-3">2.1.</span> Vector binding.</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Anything supports <b>nth</b> . <b>&amp;</b> will bind the remainder of the sequence. <b>:as</b> will bind the whole sequence.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(let [[a b c &amp; d :as e] [1 2 3 4 5 6 7]]
  [a b c d e])
-&gt;[1 2 3 (4 5 6 7) [1 2 3 4 5 6 7]]

(let [[[x1 y1][x2 y2]] [[1 2] [3 4]]]
  [x1 y1 x2 y2])
-&gt;[1 2 3 4]

(let [[a b &amp; c :as str] "asdjhhfdas"]
  [a b c str])
-&gt;[\a \s (\d \j \h \h \f \d \a \s) "asdjhhfdas"]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcfd2b91" class="outline-3">
<h3 id="orgcfd2b91"><span class="section-number-3">2.2.</span> Map binding.</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Bind to <i>Associative</i> things. map/vector/string/array(only integer keys except the map).
</p>

<p>
<b>:as</b> works as in vector binding.What's more, <b>:or</b> followed by another map can be used for default values or not-exist keys in the original map(named init-expr).
</p>

<div class="org-src-container">
<pre class="src src-clojure">(let [{a :a, b :b, c :c, :as m :or {a 2 b 3}} {:a 5 :c 6}]
  [a b c m])
-&gt;[5 3 6 {:c 6, :a 5}]
;; a is bound to the value of key ':a' in init-expr.
;; c is bound to the default value
</pre>
</div>

<p>
<b>:keys</b> for a simpler situation: symbol's name is the same as the key. <b>:strs</b> and <b>:syms</b> for string and symbol keys.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(let [{fred :fred ethel :ethel lucy :lucy} m] ...
(let [{:keys [fred ethel lucy]} m] ...
</pre>
</div>

<p>
Nested form, no need for special attention.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(let [{j :j, k :k, i :i, [r s &amp; t :as v] :ivec, :or {i 12 j 13}}
{:j 15 :k 16 :ivec [22 23 24 25]}]
[i j k r s t v])
-&gt; [12 15 16 22 23 (24 25) [22 23 24 25]]
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6358c5d" class="outline-2">
<h2 id="org6358c5d"><span class="section-number-2">3.</span> <span class="todo TODO">TODO</span> How did this happen?</h2>
</div>
