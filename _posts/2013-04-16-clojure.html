---
layout: post
title: clojure与FP
tags: [pl]
---
<div id="outline-container-org4fb3731" class="outline-2">
<h2 id="org4fb3731"><span class="section-number-2">1.</span> Clojure 初体验</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org1a57864" class="outline-3">
<h3 id="org1a57864"><span class="section-number-3">1.1.</span> 说明与动机</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>自己也是初学，介绍不深入，很简单。</li>
<li>没有大局观，不系统，小例子。</li>
<li>内容分散。</li>
<li>引用为主。</li>
<li>内容与Clojure相关性不大。</li>
<li>Progamming Language课程的学习。</li>
</ol>
</div>
</div>
<div id="outline-container-org8a15b50" class="outline-3">
<h3 id="org8a15b50"><span class="section-number-3">1.2.</span> 可能具有的一些特点</h3>
<div class="outline-text-3" id="text-1-2">
</div>
<div id="outline-container-org741d2ec" class="outline-4">
<h4 id="org741d2ec"><span class="section-number-4">1.2.1.</span> 不变数据与副作用</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
无变量，数据是不变的。性能上的问题， <b>应该是</b> 通过写时复制与重用之前的数据。副作用本身与不变数据没有必然的联系，但是不变数据是促进了无副作用的编程，因为没有变量，减少了全局变量的因素，也就限制了副作用可能产生的范围，副作用往往都是受限在一定范围内的。
</p>
</div>
</div>
<div id="outline-container-org93fe324" class="outline-4">
<h4 id="org93fe324"><span class="section-number-4">1.2.2.</span> 惰性求值</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
最近的王垠对于这一问题的批评：
</p>
<ul class="org-ul">
<li><a href="http://blog.sina.com.cn/s/blog_5d90e82f0101jz6j.html">http://blog.sina.com.cn/s/blog_5d90e82f0101jz6j.html</a></li>
</ul>


<p>
集中于性能上的讨论，惰性求值可能带来堆积和连锁效应，在某些时刻触发之前所有的堆积的操作。
</p>
</div>
</div>
</div>
<div id="outline-container-org667cb78" class="outline-3">
<h3 id="org667cb78"><span class="section-number-3">1.3.</span> 可能的优点？</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org61444e9" class="outline-4">
<h4 id="org61444e9"><span class="section-number-4">1.3.1.</span> 单元测试</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
主要是无副作用，保证了函数映射的固定，固定输入固定输出，方便了测试。与外界的变量隔离后，内部状态相对容易控制和观察，调试方便。
</p>
</div>
</div>
<div id="outline-container-org826450c" class="outline-4">
<h4 id="org826450c"><span class="section-number-4">1.3.2.</span> 并行</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
无外部变量的影响，所以竞争条件不多，没有必要增加锁。Map Reduce与hadoop 的应用。
</p>
</div>
</div>
</div>
<div id="outline-container-orge8ba8e2" class="outline-3">
<h3 id="orge8ba8e2"><span class="section-number-3">1.4.</span> 小径的主题</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org31071e4" class="outline-4">
<h4 id="org31071e4"><span class="section-number-4">1.4.1.</span> continuation</h4>
</div>
<div id="outline-container-org5564201" class="outline-4">
<h4 id="org5564201"><span class="section-number-4">1.4.2.</span> monad</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
这个不清楚，太复杂。Haskell使用。
</p>
<ul class="org-ul">
<li><a href="http://zhuoqiang.me/what-is-monad.html">http://zhuoqiang.me/what-is-monad.html</a></li>
<li><a href="http://www.iis.sinica.edu.tw/~scm/ncs/2009/11/a-monad-primer/comment-page-1/">http://www.iis.sinica.edu.tw/~scm/ncs/2009/11/a-monad-primer/comment-page-1/</a></li>
<li><a href="http://www.douban.com/group/topic/1238401/">http://www.douban.com/group/topic/1238401/</a></li>
<li><a href="http://yi-programmer.com/2010-04-06_haskell_and_category_translate.html">http://yi-programmer.com/2010-04-06_haskell_and_category_translate.html</a></li>
<li><a href="http://stefan-klinger.de/files/monadGuide.pdf">http://stefan-klinger.de/files/monadGuide.pdf</a></li>
</ul>
</div>
</div>
<div id="outline-container-org07a8a39" class="outline-4">
<h4 id="org07a8a39"><span class="section-number-4">1.4.3.</span> uniqueness</h4>
</div>
</div>
<div id="outline-container-org57d869f" class="outline-3">
<h3 id="org57d869f"><span class="section-number-3">1.5.</span> 语法</h3>
<div class="outline-text-3" id="text-1-5">
</div>
<div id="outline-container-org52fff70" class="outline-4">
<h4 id="org52fff70"><span class="section-number-4">1.5.1.</span> Lambda算子</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
之前已经有过介绍，不再多言。
<a href="http://www.slideshare.net/qinjian623/lambda-15570486">http://www.slideshare.net/qinjian623/lambda-15570486</a>
</p>
</div>
</div>
<div id="outline-container-org5b67595" class="outline-4">
<h4 id="org5b67595"><span class="section-number-4">1.5.2.</span> S-expression介绍</h4>
<div class="outline-text-4" id="text-1-5-2">
</div>
<ol class="org-ol">
<li><a id="orga326698"></a>什么是？<br />
<div class="outline-text-5" id="text-1-5-2-1">
<p>
树结构的数据格式表示形式。有形式化的文档描述，一个没有通过的RFC，地址：
<a href="http://people.csail.mit.edu/rivest/Sexp.txt">http://people.csail.mit.edu/rivest/Sexp.txt</a> 用于通讯数据。
John McCarthy最先提到。
</p>


<p>
第一代计算机科学家的年代。
</p>
<ol class="org-ol">
<li>Dennis Ritchie found dead 2011.10.12</li>
<li>John McCarthy 2011.10.24</li>
<li>Steve Jobs 2011.10.05</li>
</ol>
</div>
</li>
</ol>
</div>
<div id="outline-container-org8f6d121" class="outline-4">
<h4 id="org8f6d121"><span class="section-number-4">1.5.3.</span> XML、JSON 与S-exp的相似性</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
reinvent, 显然，三者的表达能力等价，语法相异但相近。相关的讨论.
</p>
<ul class="org-ul">
<li><a href="http://quoderat.megginson.com/2007/01/03/all-markup-ends-up-looking-like-xml/">http://quoderat.megginson.com/2007/01/03/all-markup-ends-up-looking-like-xml/</a></li>
<li><a href="http://eli.thegreenplace.net/2012/03/04/some-thoughts-on-json-vs-s-expressions/">http://eli.thegreenplace.net/2012/03/04/some-thoughts-on-json-vs-s-expressions/</a></li>
</ul>


<p>
XML相对更加接近数据，JSON和S-exp则与语言更紧密。技术哲学话题，见仁见智。
</p>
</div>
</div>
<div id="outline-container-orga3164cf" class="outline-4">
<h4 id="orga3164cf"><span class="section-number-4">1.5.4.</span> 高阶函数，Map Reduce</h4>
<div class="outline-text-4" id="text-1-5-4">
</div>
<ol class="org-ol">
<li><a id="orgc0eada6"></a>Map and Reduce<br />
<div class="outline-text-5" id="text-1-5-4-1">
<p>
<a href="http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec05.html">http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec05.html</a>
良好的数据操作的抽象，可以作为一个通用的大规模数据处理框架，因为可以并行。80年代末就存在了使用这一抽象的并行系统The Connection Machine。但是时机对于技术的影响极大，有其自己的进化路径，Google将其发扬光大，Hadoop作为Google 的Map reduce的开源实现，目前已经被被广泛应用。
</p>
<blockquote>
<p>
"Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. We realized that most of our computations involved applying a map operation to each logical record in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key in order to combine the derived data appropriately."
</p>
</blockquote>
<p>
"inspired by",视界和思维定式往往限制了一个人，虽然这一说法过于“形而上”，但是保持学习的态度，广泛的开拓视野的作用自不言说。
</p>
</div>
<ol class="org-ol">
<li><a id="orgf1eb5fb"></a>大数据 互联网大规模数据挖掘与分布式处理<br />
<div class="outline-text-6" id="text-1-5-4-1-1">
<p>
第二章利用map-reduce来实现选择、投影、并交差运算的方法，这些方法基本都可以自然的应用于具有map reduce操作语言上。
</p>
</div>
</li>
<li><a id="org54d8b3f"></a>Map func list<br />
<div class="outline-text-6" id="text-1-5-4-1-2">
<p>
将list中的每个元素都经过func进行操作，形成新的一个list。其实也可以同时操作多个list,相对的func就需要同时传入多个参数。
</p>
</div>
</li>
<li><a id="org79c7fea"></a>Reduce func init list<br />
<div class="outline-text-6" id="text-1-5-4-1-3">
<p>
func接受两个参数，以此遍历list，刚开始传入的是list的第一和第二项，然后通过func计算返回值，作为下次迭代传入的第一个参数。如有init，第一次传入的为init和list第一个项。
</p>
</div>
</li>
<li><a id="org42910dd"></a>小径<br />
<div class="outline-text-6" id="text-1-5-4-1-4">
<p>
Map自然也可以通过reduce来实现，包括filter也可以。
</p>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org9f63482" class="outline-4">
<h4 id="org9f63482"><span class="section-number-4">1.5.5.</span> call-by-value or call-by-name</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
<a href="http://www.cs.columbia.edu/~sedwards/classes/2010/w4115-spring/functional.pdf">http://www.cs.columbia.edu/~sedwards/classes/2010/w4115-spring/functional.pdf</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org86ff3e3" class="outline-3">
<h3 id="org86ff3e3"><span class="section-number-3">1.6.</span> 语法与编程范型的无关性</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-orgcd3e8a1" class="outline-4">
<h4 id="orgcd3e8a1"><span class="section-number-4">1.6.1.</span> Java的实现</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
Java也可以写出具有FP特征的代码，但是性能和理解上不舒适。
</p>
</div>
</div>
<div id="outline-container-org6fe92ce" class="outline-4">
<h4 id="org6fe92ce"><span class="section-number-4">1.6.2.</span> LISP != FP</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
最初的LISP并非满足FP.
Fortran与LISP的对比对应于图灵机与Lambda的对比。一个更加靠经硬件，一个更加靠近数学抽象。
</p>
</div>
<ol class="org-ol">
<li><a id="orgb7579b0"></a>History of Lisp by John McCarthy<br />
<div class="outline-text-5" id="text-1-6-2-1">
<p>
<a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">http://www-formal.stanford.edu/jmc/history/lisp/lisp.html</a>
</p>
</div>
</li>
<li><a id="org1839582"></a>History of Lisp by Paul Graham and also On Lisp<br />
<div class="outline-text-5" id="text-1-6-2-2">
<ul class="org-ul">
<li><a href="http://www.paulgraham.com/lisphistory.html">http://www.paulgraham.com/lisphistory.html</a></li>
<li>On Lisp，有中文翻译版本。</li>
</ul>
</div>
</li>
<li><a id="org7e5304e"></a>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp by Peter Norvig<br />
<div class="outline-text-5" id="text-1-6-2-3">
<p>
<a href="http://norvig.com/paip.html">http://norvig.com/paip.html</a>
</p>
</div>
</li>
<li><a id="orged8ab97"></a>Concepts, Techniques, and Models of Computer Programming<br />
<div class="outline-text-5" id="text-1-6-2-4">
<p>
<a href="http://www.info.ucl.ac.be/~pvr/book.html">http://www.info.ucl.ac.be/~pvr/book.html</a>
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgef37a09" class="outline-4">
<h4 id="orgef37a09"><span class="section-number-4">1.6.3.</span> 其他的语言</h4>
<div class="outline-text-4" id="text-1-6-3">
</div>
<ol class="org-ol">
<li><a id="org1855808"></a>ML-&gt; F# OCaml<br />
<div class="outline-text-5" id="text-1-6-3-1">
<p>
'Programming Language' on coursera.org
</p>
</div>
</li>
<li><a id="org4bda284"></a>LISP -&gt; ELISP /Common Lisp/Clojure &#x2026;<br />
<ol class="org-ol">
<li><a id="orgcc5da7a"></a>By GNU<br />
<div class="outline-text-6" id="text-1-6-3-2-1">
<p>
<a href="http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html">http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html</a>
</p>
</div>
</li>
<li><a id="org6a86b1c"></a>By Xah<br />
<div class="outline-text-6" id="text-1-6-3-2-2">
<p>
<a href="http://ergoemacs.org/emacs/elisp.html">http://ergoemacs.org/emacs/elisp.html</a>
</p>
</div>
</li>
<li><a id="orga7f5c58"></a>ELISP的“原始”<br />
<div class="outline-text-6" id="text-1-6-3-2-3">
<p>
dynamic scope
</p>
</div>
</li>
</ol>
</li>
<li><a id="org46363a9"></a>Scala in twitter<br />
<ol class="org-ol">
<li><a id="org4319157"></a>A Conversation with 3 people in twitter<br />
<div class="outline-text-6" id="text-1-6-3-3-1">
<p>
<a href="http://www.artima.com/scalazine/articles/twitter_on_scala.html">http://www.artima.com/scalazine/articles/twitter_on_scala.html</a>
</p>
</div>
</li>
</ol>
</li>
<li><a id="orgdfa273f"></a>Haskell<br />
<div class="outline-text-5" id="text-1-6-3-4">
<p>
纯函数式编程语言
</p>
</div>
<ol class="org-ol">
<li><a id="orgd98947b"></a>副作用<br /></li>
</ol>
</li>
</ol>
</div>
</div>
<div id="outline-container-orgc3cc8ff" class="outline-3">
<h3 id="orgc3cc8ff"><span class="section-number-3">1.7.</span> 小陶示例与运行时的性能比较</h3>
<div class="outline-text-3" id="text-1-7">
</div>
<div id="outline-container-org28e11d8" class="outline-4">
<h4 id="org28e11d8"><span class="section-number-4">1.7.1.</span> 直接版本</h4>
<div class="outline-text-4" id="text-1-7-1">
<div class="org-src-container">
<pre class="src src-clojure">(defn extend-list [char-set]
  "扩展列表方法，可将(1 2 3)，扩展为((1) (1 2))"
  (map #(take (inc (.indexOf char-set %)) char-set) (drop-last char-set)))

(defn flatten-sub-index
  "原始无优化版本"
  [char-set]
  (if (= 1 (count char-set))
    (list char-set) 
    (map #(concat % (list (last char-set)))
         (reduce #(concat %1 %2) []
                 (map flatten-sub-index (extend-list char-set))))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org217d74d" class="outline-4">
<h4 id="org217d74d"><span class="section-number-4">1.7.2.</span> memoize版本</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
函数式无副作用带来的优势，本身的基本实现也极为简单。
</p>
<div class="org-src-container">
<pre class="src src-clojure">(declare fm)
(defn flatten-sub-index-two
  [char-set]
  (if (= 1 (count char-set))
    (list char-set) 
    (map #(concat % (list (last char-set)))
         (reduce #(concat %1 %2) []
                 (map fm (extend-list char-set))))))
(def fm (memoize flatten-sub-index-two))
</pre>
</div>
</div>
<ol class="org-ol">
<li><a id="org872804f"></a>memoize 的极端简单的实现示例 in racket<br /></li>
</ol>
</div>
<div id="outline-container-org63ab294" class="outline-4">
<h4 id="org63ab294"><span class="section-number-4">1.7.3.</span> laziness版本</h4>
</div>
<div id="outline-container-orgc1152d6" class="outline-4">
<h4 id="orgc1152d6"><span class="section-number-4">1.7.4.</span> python的函数式快速排序、以及堆排序的可能性？</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
python函数式编程风格的快速排序，没有变量的引入。
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">q</span><span class="org-operator">=</span><span class="org-keyword">lambda</span> s:s <span class="org-keyword">if</span> <span class="org-builtin">len</span>(s)<span class="org-operator">&lt;</span>2 <span class="org-keyword">else</span> q([x <span class="org-keyword">for</span> x <span class="org-keyword">in</span> s[1:]<span class="org-keyword">if</span> x<span class="org-operator">&lt;</span>s[0]])<span class="org-operator">+</span>[s[0]]<span class="org-operator">+</span>q([x <span class="org-keyword">for</span> x <span class="org-keyword">in</span> s[1:]<span class="org-keyword">if</span> x<span class="org-operator">&gt;=</span>s[0]])
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcc1dc22" class="outline-4">
<h4 id="orgcc1dc22"><span class="section-number-4">1.7.5.</span> Purely Functional Data Structures until 1998</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
<a href="http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf</a>
</p>
</div>
</div>
<div id="outline-container-orgf5e6d3d" class="outline-4">
<h4 id="orgf5e6d3d"><span class="section-number-4">1.7.6.</span> New Data Structures since 1998</h4>
<div class="outline-text-4" id="text-1-7-6">
<p>
<a href="http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki">http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org3ffc00e" class="outline-3">
<h3 id="org3ffc00e"><span class="section-number-3">1.8.</span> 嵌入式语言实现、解释器</h3>
<div class="outline-text-3" id="text-1-8">
</div>
<div id="outline-container-orgdac3b1a" class="outline-4">
<h4 id="orgdac3b1a"><span class="section-number-4">1.8.1.</span> 嵌入式的eval</h4>
<div class="outline-text-4" id="text-1-8-1">
</div>
<ol class="org-ol">
<li><a id="org0be8286"></a>Racket &lt;- Scheme<br />
<div class="outline-text-5" id="text-1-8-1-1">
<p>
Lisp，语法不多言
</p>
</div>
</li>
<li><a id="org77a2552"></a>来自Programming Language[纸质材料]<br />
<div class="outline-text-5" id="text-1-8-1-2">
<p>
<a href="https://class.coursera.org/proglang-2012-001/class/index">https://class.coursera.org/proglang-2012-001/class/index</a>
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orge0b5d8c" class="outline-4">
<h4 id="orge0b5d8c"><span class="section-number-4">1.8.2.</span> bootstrap scheme的eval，其中的尾递归转化为迭代的优化实现。</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
1700 lines c, 
</p>
</div>
<ol class="org-ol">
<li><a id="org5752a8f"></a>尾递归上次提过<br /></li>
</ol>
</div>
<div id="outline-container-orgc6e1d8e" class="outline-4">
<h4 id="orgc6e1d8e"><span class="section-number-4">1.8.3.</span> 构建系统语言的实现</h4>
<div class="outline-text-4" id="text-1-8-3">
</div>
<ol class="org-ol">
<li><a id="orgb1db088"></a>makefile or ant<br />
<div class="outline-text-5" id="text-1-8-3-1">
<p>
仅仅在计划上，预计不会继续。
</p>
</div>
</li>
<li><a id="orge2dc4db"></a>csv的dsl语言<br />
<div class="outline-text-5" id="text-1-8-3-2">
<p>
实现一个很简单的对csv进行操作的类SQL。
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orgef13ab0" class="outline-4">
<h4 id="orgef13ab0"><span class="section-number-4">1.8.4.</span> Java的尾递归的上层构建过程</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
《The Role of the Study of Programming Languages in the Education of a Programmer》
</p>
</div>
</div>
</div>
<div id="outline-container-org760f45d" class="outline-3">
<h3 id="org760f45d"><span class="section-number-3">1.9.</span> 杂交化的趋势</h3>
<div class="outline-text-3" id="text-1-9">
<p>
两个方向，与分久必合。
</p>
</div>
<div id="outline-container-org192109f" class="outline-4">
<h4 id="org192109f"><span class="section-number-4">1.9.1.</span> C++ lambda引入</h4>
</div>
<div id="outline-container-org8e2ec68" class="outline-4">
<h4 id="org8e2ec68"><span class="section-number-4">1.9.2.</span> jvm class file dynamic 的类型引入，支持上层动态语言</h4>
</div>
</div>
</div>
<div id="outline-container-orgd9cdefb" class="outline-2">
<h2 id="orgd9cdefb"><span class="section-number-2">2.</span> 没有银弹</h2>
</div>
