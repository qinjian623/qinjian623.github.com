---
layout: post
title: clojure与FP
tags: [pl]
---
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Clojure 初体验</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 说明与动机</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>自己也是初学，介绍不深入，很简单。
</li>
<li>没有大局观，不系统，小例子。
</li>
<li>内容分散。
</li>
<li>引用为主。
</li>
<li>内容与Clojure相关性不大。
</li>
<li>Progamming Language课程的学习。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 可能具有的一些特点</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 不变数据与副作用</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
无变量，数据是不变的。性能上的问题， <b>应该是</b> 通过写时复制与重用之前的数据。副作用本身与不变数据没有必然的联系，但是不变数据是促进了无副作用的编程，因为没有变量，减少了全局变量的因素，也就限制了副作用可能产生的范围，副作用往往都是受限在一定范围内的。
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 惰性求值</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
最近的王垠对于这一问题的批评：
</p>
<ul class="org-ul">
<li><a href="http://blog.sina.com.cn/s/blog_5d90e82f0101jz6j.html">http://blog.sina.com.cn/s/blog_5d90e82f0101jz6j.html</a>
</li>
</ul>


<p>
集中于性能上的讨论，惰性求值可能带来堆积和连锁效应，在某些时刻触发之前所有的堆积的操作。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 可能的优点？</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 单元测试</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
主要是无副作用，保证了函数映射的固定，固定输入固定输出，方便了测试。与外界的变量隔离后，内部状态相对容易控制和观察，调试方便。
</p>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 并行</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
无外部变量的影响，所以竞争条件不多，没有必要增加锁。Map Reduce与hadoop 的应用。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 小径的主题</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> continuation</h4>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> monad</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
这个不清楚，太复杂。Haskell使用。
</p>
<ul class="org-ul">
<li><a href="http://zhuoqiang.me/what-is-monad.html">http://zhuoqiang.me/what-is-monad.html</a>
</li>
<li><a href="http://www.iis.sinica.edu.tw/~scm/ncs/2009/11/a-monad-primer/comment-page-1/">http://www.iis.sinica.edu.tw/~scm/ncs/2009/11/a-monad-primer/comment-page-1/</a>
</li>
<li><a href="http://www.douban.com/group/topic/1238401/">http://www.douban.com/group/topic/1238401/</a>
</li>
<li><a href="http://yi-programmer.com/2010-04-06_haskell_and_category_translate.html">http://yi-programmer.com/2010-04-06_haskell_and_category_translate.html</a>
</li>
<li><a href="http://stefan-klinger.de/files/monadGuide.pdf">http://stefan-klinger.de/files/monadGuide.pdf</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> uniqueness</h4>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> 语法</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> Lambda算子</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
之前已经有过介绍，不再多言。
<a href="http://www.slideshare.net/qinjian623/lambda-15570486">http://www.slideshare.net/qinjian623/lambda-15570486</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> S-expression介绍</h4>
<div class="outline-text-4" id="text-1-5-2">
</div><ol class="org-ol"><li>什么是？<br/><div class="outline-text-5" id="text-1-5-2-1">
<p>
树结构的数据格式表示形式。有形式化的文档描述，一个没有通过的RFC，地址：
<a href="http://people.csail.mit.edu/rivest/Sexp.txt">http://people.csail.mit.edu/rivest/Sexp.txt</a> 用于通讯数据。
John McCarthy最先提到。
</p>


<p>
第一代计算机科学家的年代。
</p>
<ol class="org-ol">
<li>Dennis Ritchie found dead 2011.10.12
</li>
<li>John McCarthy 2011.10.24
</li>
<li>Steve Jobs 2011.10.05
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> XML、JSON 与S-exp的相似性</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
reinvent, 显然，三者的表达能力等价，语法相异但相近。相关的讨论.
</p>
<ul class="org-ul">
<li><a href="http://quoderat.megginson.com/2007/01/03/all-markup-ends-up-looking-like-xml/">http://quoderat.megginson.com/2007/01/03/all-markup-ends-up-looking-like-xml/</a>
</li>
<li><a href="http://eli.thegreenplace.net/2012/03/04/some-thoughts-on-json-vs-s-expressions/">http://eli.thegreenplace.net/2012/03/04/some-thoughts-on-json-vs-s-expressions/</a>
</li>
</ul>


<p>
XML相对更加接近数据，JSON和S-exp则与语言更紧密。技术哲学话题，见仁见智。
</p>
</div>
</div>

<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4"><span class="section-number-4">1.5.4</span> 高阶函数，Map Reduce</h4>
<div class="outline-text-4" id="text-1-5-4">
</div><ol class="org-ol"><li>Map and Reduce<br/><div class="outline-text-5" id="text-1-5-4-1">
<p>
<a href="http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec05.html">http://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec05.html</a>
良好的数据操作的抽象，可以作为一个通用的大规模数据处理框架，因为可以并行。80年代末就存在了使用这一抽象的并行系统The Connection Machine。但是时机对于技术的影响极大，有其自己的进化路径，Google将其发扬光大，Hadoop作为Google 的Map reduce的开源实现，目前已经被被广泛应用。
</p>
<blockquote>
<p>
"Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. We realized that most of our computations involved applying a map operation to each logical record in our input in order to compute a set of intermediate key/value pairs, and then applying a reduce operation to all the values that shared the same key in order to combine the derived data appropriately."
</p>
</blockquote>
<p>
"inspired by",视界和思维定式往往限制了一个人，虽然这一说法过于“形而上”，但是保持学习的态度，广泛的开拓视野的作用自不言说。
</p>
</div>
<ol class="org-ol"><li>大数据 互联网大规模数据挖掘与分布式处理<br/><div class="outline-text-6" id="text-1-5-4-1-1">
<p>
第二章利用map-reduce来实现选择、投影、并交差运算的方法，这些方法基本都可以自然的应用于具有map reduce操作语言上。
</p>
</div>
</li>

<li>Map func list<br/><div class="outline-text-6" id="text-1-5-4-1-2">
<p>
将list中的每个元素都经过func进行操作，形成新的一个list。其实也可以同时操作多个list,相对的func就需要同时传入多个参数。
</p>
</div>
</li>

<li>Reduce func init list<br/><div class="outline-text-6" id="text-1-5-4-1-3">
<p>
func接受两个参数，以此遍历list，刚开始传入的是list的第一和第二项，然后通过func计算返回值，作为下次迭代传入的第一个参数。如有init，第一次传入的为init和list第一个项。
</p>
</div>
</li>

<li>小径<br/><div class="outline-text-6" id="text-1-5-4-1-4">
<p>
Map自然也可以通过reduce来实现，包括filter也可以。
</p>
</div>
</li></ol>
</li></ol>
</div>

<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5"><span class="section-number-4">1.5.5</span> call-by-value or call-by-name</h4>
<div class="outline-text-4" id="text-1-5-5">
<p>
<a href="http://www.cs.columbia.edu/~sedwards/classes/2010/w4115-spring/functional.pdf">http://www.cs.columbia.edu/~sedwards/classes/2010/w4115-spring/functional.pdf</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> 语法与编程范型的无关性</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> Java的实现</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
Java也可以写出具有FP特征的代码，但是性能和理解上不舒适。
</p>
</div>
</div>

<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> LISP != FP</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
最初的LISP并非满足FP.
Fortran与LISP的对比对应于图灵机与Lambda的对比。一个更加靠经硬件，一个更加靠近数学抽象。
</p>
</div>
<ol class="org-ol"><li>History of Lisp by John McCarthy<br/><div class="outline-text-5" id="text-1-6-2-1">
<p>
<a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">http://www-formal.stanford.edu/jmc/history/lisp/lisp.html</a>
</p>
</div>
</li>

<li>History of Lisp by Paul Graham and also On Lisp<br/><div class="outline-text-5" id="text-1-6-2-2">
<ul class="org-ul">
<li><a href="http://www.paulgraham.com/lisphistory.html">http://www.paulgraham.com/lisphistory.html</a>
</li>
<li>On Lisp，有中文翻译版本。 
</li>
</ul>
</div>
</li>

<li>Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp by Peter Norvig<br/><div class="outline-text-5" id="text-1-6-2-3">
<p>
<a href="http://norvig.com/paip.html">http://norvig.com/paip.html</a>
</p>
</div>
</li>

<li>Concepts, Techniques, and Models of Computer Programming<br/><div class="outline-text-5" id="text-1-6-2-4">
<p>
<a href="http://www.info.ucl.ac.be/~pvr/book.html">http://www.info.ucl.ac.be/~pvr/book.html</a>
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3"><span class="section-number-4">1.6.3</span> 其他的语言</h4>
<div class="outline-text-4" id="text-1-6-3">
</div><ol class="org-ol"><li>ML-&gt; F# OCaml<br/><div class="outline-text-5" id="text-1-6-3-1">
<p>
'Programming Language' on coursera.org
</p>
</div>
</li>

<li>LISP -&gt; ELISP /Common Lisp/Clojure &#x2026;<br/><ol class="org-ol"><li>By GNU<br/><div class="outline-text-6" id="text-1-6-3-2-1">
<p>
<a href="http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html">http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html</a>
</p>
</div>
</li>

<li>By Xah<br/><div class="outline-text-6" id="text-1-6-3-2-2">
<p>
<a href="http://ergoemacs.org/emacs/elisp.html">http://ergoemacs.org/emacs/elisp.html</a>
</p>
</div>
</li>

<li>ELISP的“原始”<br/><div class="outline-text-6" id="text-1-6-3-2-3">
<p>
dynamic scope
</p>
</div>
</li></ol>
</li>

<li>Scala in twitter<br/><ol class="org-ol"><li>A Conversation with 3 people in twitter<br/><div class="outline-text-6" id="text-1-6-3-3-1">
<p>
<a href="http://www.artima.com/scalazine/articles/twitter_on_scala.html">http://www.artima.com/scalazine/articles/twitter_on_scala.html</a>
</p>
</div>
</li></ol>
</li>

<li>Haskell<br/><div class="outline-text-5" id="text-1-6-3-4">
<p>
纯函数式编程语言
</p>
</div>
<ol class="org-ol"><li>副作用<br/></li></ol>
</li></ol>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> 小陶示例与运行时的性能比较</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1"><span class="section-number-4">1.7.1</span> 直接版本</h4>
<div class="outline-text-4" id="text-1-7-1">
<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #7f7f7f;">(</span><span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">extend-list</span> [char-set]
  <span style="color: #61CE3C;">"&#25193;&#23637;&#21015;&#34920;&#26041;&#27861;&#65292;&#21487;&#23558;(1 2 3)&#65292;&#25193;&#23637;&#20026;((1) (1 2))"</span>
  <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">map</span> #<span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">take</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">inc</span> <span style="color: #7f7f7f;">(</span><span style="color: #919191;">.indexOf</span> char-set %<span style="color: #7f7f7f;">))</span> char-set<span style="color: #7f7f7f;">)</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">drop-last</span> char-set<span style="color: #7f7f7f;">)))</span>

<span style="color: #7f7f7f;">(</span><span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">flatten-sub-index</span>
  <span style="color: #61CE3C;">"&#21407;&#22987;&#26080;&#20248;&#21270;&#29256;&#26412;"</span>
  [char-set]
  <span style="color: #7f7f7f;">(</span><span style="color: #FBDE2D;">if</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">=</span> 1 <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">count</span> char-set<span style="color: #7f7f7f;">))</span>
    <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">list</span> char-set<span style="color: #7f7f7f;">)</span> 
    <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">map</span> #<span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">concat</span> % <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">list</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">last</span> char-set<span style="color: #7f7f7f;">)))</span>
         <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">reduce</span> #<span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">concat</span> %1 %2<span style="color: #7f7f7f;">)</span> []
                 <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">map</span> flatten-sub-index <span style="color: #7f7f7f;">(</span>extend-list char-set<span style="color: #7f7f7f;">))))))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-2" class="outline-4">
<h4 id="sec-1-7-2"><span class="section-number-4">1.7.2</span> memoize版本</h4>
<div class="outline-text-4" id="text-1-7-2">
<p>
函数式无副作用带来的优势，本身的基本实现也极为简单。
</p>
<div class="org-src-container">

<pre class="src src-clojure"><span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">declare</span> fm<span style="color: #7f7f7f;">)</span>
<span style="color: #7f7f7f;">(</span><span style="color: #FBDE2D;">defn</span> <span style="color: #ff1493;">flatten-sub-index-two</span>
  [char-set]
  <span style="color: #7f7f7f;">(</span><span style="color: #FBDE2D;">if</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">=</span> 1 <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">count</span> char-set<span style="color: #7f7f7f;">))</span>
    <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">list</span> char-set<span style="color: #7f7f7f;">)</span> 
    <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">map</span> #<span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">concat</span> % <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">list</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">last</span> char-set<span style="color: #7f7f7f;">)))</span>
         <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">reduce</span> #<span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">concat</span> %1 %2<span style="color: #7f7f7f;">)</span> []
                 <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">map</span> fm <span style="color: #7f7f7f;">(</span>extend-list char-set<span style="color: #7f7f7f;">))))))</span>
<span style="color: #7f7f7f;">(</span><span style="color: #FBDE2D;">def</span> <span style="color: #ff1493;">fm</span> <span style="color: #7f7f7f;">(</span><span style="color: #FF6400;">memoize</span> flatten-sub-index-two<span style="color: #7f7f7f;">))</span>
</pre>
</div>
</div>
<ol class="org-ol"><li>memoize 的极端简单的实现示例 in racket<br/></li></ol>
</div>

<div id="outline-container-sec-1-7-3" class="outline-4">
<h4 id="sec-1-7-3"><span class="section-number-4">1.7.3</span> laziness版本</h4>
</div>
<div id="outline-container-sec-1-7-4" class="outline-4">
<h4 id="sec-1-7-4"><span class="section-number-4">1.7.4</span> python的函数式快速排序、以及堆排序的可能性？</h4>
<div class="outline-text-4" id="text-1-7-4">
<p>
python函数式编程风格的快速排序，没有变量的引入。
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #D8FA3C;">q</span>=<span style="color: #FBDE2D;">lambda</span> s:s <span style="color: #FBDE2D;">if</span> <span style="color: #FF6400;">len</span>(s)&lt;2 <span style="color: #FBDE2D;">else</span> q([x <span style="color: #FBDE2D;">for</span> x <span style="color: #FBDE2D;">in</span> s[1:]<span style="color: #FBDE2D;">if</span> x&lt;s[0]])+[s[0]]+q([x <span style="color: #FBDE2D;">for</span> x <span style="color: #FBDE2D;">in</span> s[1:]<span style="color: #FBDE2D;">if</span> x&gt;=s[0]])
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-7-5" class="outline-4">
<h4 id="sec-1-7-5"><span class="section-number-4">1.7.5</span> Purely Functional Data Structures until 1998</h4>
<div class="outline-text-4" id="text-1-7-5">
<p>
<a href="http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf</a>
</p>
</div>
</div>

<div id="outline-container-sec-1-7-6" class="outline-4">
<h4 id="sec-1-7-6"><span class="section-number-4">1.7.6</span> New Data Structures since 1998</h4>
<div class="outline-text-4" id="text-1-7-6">
<p>
<a href="http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki">http://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki</a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> 嵌入式语言实现、解释器</h3>
<div class="outline-text-3" id="text-1-8">
</div><div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1"><span class="section-number-4">1.8.1</span> 嵌入式的eval</h4>
<div class="outline-text-4" id="text-1-8-1">
</div><ol class="org-ol"><li>Racket &lt;- Scheme<br/><div class="outline-text-5" id="text-1-8-1-1">
<p>
Lisp，语法不多言
</p>
</div>
</li>

<li>来自Programming Language[纸质材料]<br/><div class="outline-text-5" id="text-1-8-1-2">
<p>
<a href="https://class.coursera.org/proglang-2012-001/class/index">https://class.coursera.org/proglang-2012-001/class/index</a>
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2"><span class="section-number-4">1.8.2</span> bootstrap scheme的eval，其中的尾递归转化为迭代的优化实现。</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
1700 lines c, 
</p>
</div>
<ol class="org-ol"><li>尾递归上次提过<br/></li></ol>
</div>

<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3"><span class="section-number-4">1.8.3</span> 构建系统语言的实现</h4>
<div class="outline-text-4" id="text-1-8-3">
</div><ol class="org-ol"><li>makefile or ant<br/><div class="outline-text-5" id="text-1-8-3-1">
<p>
仅仅在计划上，预计不会继续。
</p>
</div>
</li>

<li>csv的dsl语言<br/><div class="outline-text-5" id="text-1-8-3-2">
<p>
实现一个很简单的对csv进行操作的类SQL。
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4"><span class="section-number-4">1.8.4</span> Java的尾递归的上层构建过程</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
《The Role of the Study of Programming Languages in the Education of a Programmer》
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> 杂交化的趋势</h3>
<div class="outline-text-3" id="text-1-9">
<p>
两个方向，与分久必合。
</p>
</div>
<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1"><span class="section-number-4">1.9.1</span> C++ lambda引入</h4>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><span class="section-number-4">1.9.2</span> jvm class file dynamic 的类型引入，支持上层动态语言</h4>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 没有银弹</h2>
</div>
