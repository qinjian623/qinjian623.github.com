#+BEGIN_HTML
---
layout: post
title: 减肥菜谱little scheme
tags: [笔记]
---
#+END_HTML
* 前言
  花了大概一天的时间看完了The little scheme。全书前前后后加起来不过200多页。起码这点上这书算得上little，当然，要是算上姊妹篇，算了，还是别算了，算上就是huge了，看完一定就恶心了。

  作者么，王垠大大的老师。身为王大脑残粉，这本书现在才来看已经是应该被油炸了，以弥补自己没有做到基本的脑残粉的指责啊。

  一般来说，剧透都要挨千刀的，而我一直也都乐于享受那挨千刀的特殊快感。但是，这本书我实在是透不出来，只因自己实在资历浅，智商低，看不懂剧情。但是，我深深的觉得减肥的一定要看这本书，因为书中内容真的真的很适合减肥。

* scheme基本语法
  书的内容基本介绍的是scheme，确实仅仅”基本“是scheme，剩下的都不是scheme了。剩下的不是scheme的东西就比较多了，总共200多页的书，大概有200多页说的都是这些剩下的东西。本来么，lisp没什么语法可介绍的，看着别的书介绍语法都可以弄的比little scheme这本书还厚了，实在是替作者不平啊。

* 递归
  毕竟目标读者是初学者，所以递归就是一步一步来的，最基本的慢慢增长的一个函数体一个递归调用，到一个函数体，递归调用乱入。亏得自己也是被调教过的，所以，这个方面的东西还是扫一眼就明白了。作者还是很体贴的过段时间就要总结总结给一个Commandment。

  当然，其实递归与求极限有点类似。递归的目的当然不是为了烧CPU，浪费电，破坏熊猫们的美好家园，那是挖比特币的人干的，回到递归，总是要结束的。但是结束总要一个指标吧，其实像极限一样，是不是收敛到某一点上。递归的收敛就看返回条件了，书中的例子都是教科书般的，确实，本来书就是教科书，所有的递归结束条件都是数值下降到0,或者列表前进到null。实际运用可能就没有教科书这么漂亮了，可以是某一个人工定义的值，到了这个值就结束。既然是逼近的，也就类似梯度下降的情况，也存在无法逼近的无限递归了，在结束值上下跳动的就是这种，当然也还有非收敛的情况，这就更明显了。

* FP模式的一次次暗示
  真的是暗示，没有任何明示的，作者真是循循善诱啊。函数的“第一级”地位，都是提前挖了坑的，然后慢慢把你推进去。还有就是利用函数进行抽象的设计思路，作者都是一步步的来。相对来说比较自然，其实就是一个设计思路再一个个的连续的问题下展示出来，看，码农的本质表现出来了，单词量不够啊，表述不出来。用模式一词有点糟蹋了作者的精心设计，可以说是思想吧，当然，都是很基础的思想。哪怕有高级的我也领悟不到的，初级的还是可以看出来端倪的。当然这种模式和设计模式那种人为的设计有所区别，模式么，是自然所表现出来的共同特性，所以模式理应是一种事物做具备的自然属性，而不是人工属性。人工属性的，那叫做规则。

* 几个不断进化的Commandment
  其实，这些Commandment对非非常的初学者来说没有多大意义，很多都是很自然的逻辑，没必要拿出来当做教条，但是把这几个东西不断的修正路线理一理还是可以看出来程序设计的通用性实践是如何建立起来的，这个通用性实践，可以说就是设计模式吧。其中着重的就是递归程序设计中的一些设计模式，比如对数字、非递归的列表、树形列表的一些递归的设计思路，当然这个其实没有必要记忆，是很自然的逻辑。不过这些Commandment非常具体的描述了这些自然的逻辑。

* 丘奇编码
  函数式，这个自然离不开，里面实现了数字的丘奇编码。还有一些集合以及逻辑的操作。这个作者这个坏蛋也是没说出来的，魂淡啊，瞬间感觉到了作者在读者看这些内容的时候的智力优越感。当然，这还不止，后面还有更有优越感的东西，作者也都没有说出来。但是啊，话说评价应该客观的不是么，所以，作者还是给了出处的线索的，认真帝应该还是可以感受到那种丝丝证据终获奇特财富的感觉。可惜啊，我觉得，这个时候作者依然会坏笑着在一旁偷看这些认真帝们的。大师之所以是大师，就是因为他能多看几步，既见森林，也见树木，你的一步步都在人家手掌。

* 程序设计
  自底向上的，也有自顶向下的开发方式都有以及两者的结合，都是慢慢的从一个小小的思路慢慢扩展，最后实现程序的实体。这玩意也确实只能在lisp上出现了，你要是换成C系的语言，就请先学一个学期的语法、熟悉环境吧。当然，也可能是自己毕竟不是小白，回头来看的结果。换成自己大一的时候，估摸着也要糊涂到死槽方尽。
  
* 中、前缀语法的简单说明
  这个自然是lisp的语法了，但是不是最开始说明的，而是几章过后，作者整了个比较简单的计算器的语法解释器。先是地球人使用的中缀，然后，欢迎加入火星的前缀表示法，该成了前缀实现。当然，这个解释器很“简单”，因为别急，后面作者还给了一个scheme自己的解释器，当然，老规矩，作者也是就那么一提，没具体说是什么东西。

* FP终于出现
  在Lambda Ultimate一章中，FP终于告别了影子模式，走上前台。当然，老规矩，作者没提这个名字。而且在这章中，抽象、函数、分层、简化都大爆发了。作者也提了lambda的语法，不过这个已经不怎么重要了。作者将几个之前的函数又摆弄出来了，感觉功能不够强悍，于是往上加功能，然后发现类似的功能比较接近么，合起来吧，怎么合：抽象、传函数。然后又发现，妈的，不同功能的代码实现长得也挺像的，合吧，怎么合，继续传函数。最后把差不多能变的东西都给改成函数传进去了，剩下就是不怎么能改动骨架了。那玩意我估摸着应该就叫做框架了，所以么，我个人理解，框架么，重要的不是这个框架有多么多么多的功能，重要的是把共同点都抽象出来，需要变化的都给整成变量，当然这里的变量包括文件、函数等等了。
  作者这么流氓的改动，感觉完全就是拿着diff工具匹配代码，看着diff出来比较接近的，不用管功能、逻辑什么，改吧，改动到可以合二为一。用一句话来说就是"Ask yourself what the difference is"。

* 其他问题
  书中还有不少其他问题，就集中放一起：
** 图灵停机问题
   作者顺带给读者证明了下图灵停机问题。作者说不定心里也痒痒想把不完备定理也放进来。这个作者貌似也老规矩没说是什么，当然问题提出来貌似也比较突兀，相对书里其他的自然演进。这个放在初学者的书里倒也别有洞天。不过自己看到这个内容就过了一遍，不想再仔细看了。

** 递归与函数不动点问题
   lambda算子的递归和不动点，这个也是函数编程里面的内容，作者也把过程走了一遍，自己实在不想一天死太多脑细胞，于是就简单扫了扫了，基本算是跳过了，回头要是哪天自己蛋疼了，可以再翻一翻么。其实，上句话是自我欺骗......

** Continuation
   这个作者也是简单提了提，真的只是很简单提了下。

* 解释器
  应该是最后一章的内容吧，实现的就是一个scheme的解释器了。考虑到自己也用racket写过，这章就过的比较快了，突突突，就过去了，原理基本和自己实现的都一样，当然，这玩意原理肯定只能是一样的了，王大大自己也有文章说如何写一个解释器的。Coursera上也有Programming Language的课程，我的解释器就是课程里的作业。

* 总结
  后面还有个书单推荐列表，我看了看，尼玛我认得出的那几个名字都是重量级经典，剩下更多不认识也就不用说了。我只想说，他妈本科入门开的什么JB程序设计课程，直接用这本就成，后面的书单早点给学生看到可以让学生少浪费多少时间？坑爹教授用心查一查几个领头大学的课程表再设计课程体系也不至于这样。
  还有了，全书无时无刻都在用实践说明，逻辑简化和设计先于代码的基本编程要求。
#+begin_quote 
  "When the difference you see, the truth you see."
  "Yeah，about  Newton and Calculus I'm talking."
  "Fine, and Leibnitz."
  "Feel the Force I will,bye." -- Fake Yoda
#+end_quote

