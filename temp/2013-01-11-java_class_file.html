---
layout: post
title: Java Class File Format
tags: [pl, java]
---



<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Reference</h2>
<div class="outline-text-2" id="text-1">

<ol>
<li><a href="http://en.wikipedia.org/wiki/Java_class_file">http://en.wikipedia.org/wiki/Java_class_file</a>
</li>
<li>Java Specification Request-202 Chapter 4
</li>
</ol>



</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">文件头</h2>
<div class="outline-text-2" id="text-2">




<pre class="example">struct Class_File_Format {
   u4 magic_number;   

   u2 minor_version;   
   u2 major_version;   

   u2 constant_pool_count;   

   cp_info constant_pool[constant_pool_count - 1];

   u2 access_flags;

   u2 this_class;
   u2 super_class;

   u2 interfaces_count;   

   u2 interfaces[interfaces_count];

   u2 fields_count;   
   field_info fields[fields_count];

   u2 methods_count;
   method_info methods[methods_count];

   u2 attributes_count;   
   attribute_info attributes[attributes_count];
}
</pre>


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1">magic_number</h3>
<div class="outline-text-3" id="text-2-1">

<p>   固定值 "0xcafebabe",但是在一个文件中看到的竟然是 <b>c38a c3be c2ba c2be</b> ,只好换一个文件看了.
</p><blockquote>

<p>  A Java virtual machine implementation can support a class
ﬁle format of version v if and only if v lies in some contiguous
range Mi.0 ≤ v ≤Mj.m. Only Sun can specify what range of
versions a Java virtual machine implementation conforming to a
certain release level of the Java platform may support.
</p>
</blockquote>


</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2">minor_version and major_version</h3>
<div class="outline-text-3" id="text-2-2">

<p>   看到的两个都是 <b>0000 0032</b> ,
</p>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3">constant_pool_count and constant_pool</h3>
<div class="outline-text-3" id="text-2-3">

<p>   constant_pool 范围是 1~constant_pool_count-1,
   constant_pool中的数据结构是变长的:
</p>


<pre class="example">cp_info {
  u1 tag;
  u2 info[];
}
</pre>

<p>
   前面的tag表明类型.类型表格:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="right" />
</colgroup>
<tbody>
<tr><td class="left">Constant Type</td><td class="right">Value</td></tr>
<tr><td class="left">CONSTANT_Class</td><td class="right">7</td></tr>
<tr><td class="left">CONSTANT_Fieldref</td><td class="right">9</td></tr>
<tr><td class="left">CONSTANT_Methodref</td><td class="right">10</td></tr>
<tr><td class="left">CONSTANT_InterfaceMethorref</td><td class="right">11</td></tr>
<tr><td class="left">CONSTANT_String</td><td class="right">8</td></tr>
<tr><td class="left">CONSTANT_Integer</td><td class="right">3</td></tr>
<tr><td class="left">CONSTANT_Float</td><td class="right">4</td></tr>
<tr><td class="left">CONSTANT_Long</td><td class="right">5</td></tr>
<tr><td class="left">CONSTANT_Double</td><td class="right">6</td></tr>
<tr><td class="left">CONSTANT_NameAndType</td><td class="right">12</td></tr>
<tr><td class="left">CONSTANT_Utf8</td><td class="right">1</td></tr>
</tbody>
</table>

   后面跟随的是则是根据tag不同的结构.


</div>

<div id="outline-container-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">CONSTANT_Class</h4>
<div class="outline-text-4" id="text-2-3-1">




<pre class="example">CONSTANT_Class_info {
  u1 tag;
  u2 name_index;
}
</pre>

<p>
    注意,这里代表的是cp<sub>info的整个</sub>,所以也包括了tag.name_index则代表的具体的名称的index,具体的名称同样也会在pool里面,指向的类型应该是 CONSTANT_Utf8_info 的类型.
</p>
<p>
    数组也是对象,表示形式比较特殊:
</p>


<pre class="example">int[][] =&gt; [[I
Thread[] =&gt; [Ljava/lang/Thread;
</pre>

<blockquote>

<p>An array type descriptor is valid only if it represents 255 or fewer dimensions.
</p>
</blockquote>


<p>
    这句是什么意思呢?最多只支持255维度?
</p>
</div>

</div>

<div id="outline-container-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">CONSTANT_*ref_info</h4>
<div class="outline-text-4" id="text-2-3-2">

<p>    *代表的是Field/Method/Interface,这几个结构一致.
</p>


<pre class="example">CONSTANT_*ref_info {
  u1 tag;
  u2 class_index;
  u2 name_and_type_index;
}
</pre>

<ul>
<li id="sec-2-3-2-1">class_index<br/>
     指向的内容,必须是 CONSTANT_Class_info 的结构. 而Methodref指向的不能是interface而只能是class.Interfaceref的只能是interface. Fieldref的则两种随便.

</li>
</ul>
<ul>
<li id="sec-2-3-2-2">name_and_type_index<br/>
     指向的则是 CONSTANT_NameAndType_info, 这个表述的是method/field的名字和描述<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>.field的必须是一个field descriptor. CONSTANT_Methodref_info的名字如果以 '&lt;' 开始, 就需要是固定的 &lt;init&gt; ,表示 an instance initialization method, 其返回值必须是void.
<ul>
<li id="sec-2-3-2-2-1">field descriptor<br/>



<pre class="example">  A field descriptor represents the type of a class, instance, or local variable. It is a series of characters generated by the grammar
FieldDescriptor:
  FieldType
ComponentType:
  FieldType
FieldType:
  BaseType
ObjectType
  ArrayType
BaseType:
  *B*
  *C*
  *D*
  *F*
  *I*
  *J*
  *S*
  *Z*
ObjectType:
  L Classname;
ArrayType:
  [ComponentType
</pre>


<p>
      /BaseType/的对应表格如下:
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">BaseType Character</td><td class="left">Type</td><td class="left">Interpretation</td></tr>
<tr><td class="left">B</td><td class="left">byte</td><td class="left">signed byte</td></tr>
<tr><td class="left">C</td><td class="left">char</td><td class="left">Unicode character</td></tr>
<tr><td class="left">D</td><td class="left">double</td><td class="left">double-precision floating-point value</td></tr>
<tr><td class="left">F</td><td class="left">float</td><td class="left">single-precision floating-point value</td></tr>
<tr><td class="left">I</td><td class="left">int</td><td class="left">integer</td></tr>
<tr><td class="left">J</td><td class="left">long</td><td class="left">long integer</td></tr>
<tr><td class="left">L Classname;</td><td class="left">reference</td><td class="left">an instance of class &lt;classname&gt;</td></tr>
<tr><td class="left">S</td><td class="left">short</td><td class="left">signed short</td></tr>
<tr><td class="left">Z</td><td class="left">boolean</td><td class="left">true or false</td></tr>
<tr><td class="left">[</td><td class="left">reference</td><td class="left">one array dimension</td></tr>
</tbody>
</table>


</li>
</ul>
<ul>
<li id="sec-2-3-2-2-2">剩下的都要是method descriptor<br/>
      直接引用吧:



<pre class="example">MethodDescriptor:
  ( ParameterDescriptor* ) ReturnDescriptor
A parameter descriptor represents a parameter passed to a method:
ParameterDescriptor:
  FieldType
A return descriptor represents the type of the value returned from a method. It is a
series of characters generated by the grammar:

ReturnDescriptor:
  FieldType
  VoidDescriptor

VoidDescriptor:
  *V*
</pre>

<p>
这里,parameters的length要少于等于255.具体的length计算要包括所有的parameters的和, <b>long</b> 或者 <b>double</b> 代表两个单元,而其他的都代表一个单元<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup>.还要注意,实体类和接口方法调用的时候,this这个参数也是要算进去的<sup><a class="footref" name="fnr-.3" href="#fn-.3">3</a></sup>.
</p>
<blockquote>

<p>  Object mymethod(int i, double d, Thread t)
=&gt; (IDLjava/lang/Thread;)Ljava/lang/Object;
</p>
</blockquote>


</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-3-3" class="outline-4">
<h4 id="sec-2-3-3">CONSTANT_String_info</h4>
<div class="outline-text-4" id="text-2-3-3">




<pre class="example">CONSTANT_String_info {
  u1 tag;
  u2 string_index;
}
</pre>


<p>
比较简单,index指向的必须是 CONSTANT_Utf8_info
</p>
</div>

</div>

<div id="outline-container-2-3-4" class="outline-4">
<h4 id="sec-2-3-4">CONSTANT_Integer_info and CONSTANT_Float_info</h4>
<div class="outline-text-4" id="text-2-3-4">




<pre class="example">CONSTANT_*_info {
  u1 tag;
  u4 bytes;
}
</pre>


<p>
bytes中保存是常量的值,其中float的是IEEE 754 floating-point single format.都是big-endian.
表示float的value,首先转换为int,直接引用:
</p><blockquote>

<ul>
<li>If bits is 0x7f800000, the float value will be positive inﬁnity.
</li>
<li>If bits is 0xff800000, the float value will be negative inﬁnity.
</li>
<li>If bits is in the range 0x7f800001 through 0x7fffffff or in the range 0xff800001 through 0xffffffff, the float value will be NaN.
</li>
<li>In all other cases, let s, e, and m be three values that might be computed from bits:
<ul>
<li>int s = ((bits &gt;&gt; 31) == 0) ? 1 : -1;
</li>
<li>int e = ((bits &gt;&gt; 23) &amp; 0xff);
</li>
<li>int m = (e == 0) ?
       (bits &amp; 0x7fffff) &lt;&lt; 1 :
       (bits &amp; 0x7fffff) | 0x800000;
</li>
<li>Then the float value equals the result of the mathematical expression . s * m* 2<sup>(e-150)</sup>
</li>
</ul>

</li>
</ul>



</blockquote>


</div>

</div>

<div id="outline-container-2-3-5" class="outline-4">
<h4 id="sec-2-3-5">CONSTANT_Long_info and CONSTANT_Double_info</h4>
<div class="outline-text-4" id="text-2-3-5">




<pre class="example">CONSTANT_*_info {
  u1 tag;
  u4 high_bytes;
  u4 low_bytes;
}
</pre>


<p>
这里计算index有个特殊情况,这两个结构一次占用两个位置.
</p>


<pre class="example">All 8-byte constants take up two entries in the constant_pool table of the class
ﬁle. If a CONSTANT_Long_info or CONSTANT_Double_info structure is the item
in the constant_pool table at index n, then the next usable item in the pool is
located at index n +2. The constant_pool index n +1 must be valid but is
considered unusable.
</pre>

<p>
基本类似上面的integer和float,只不过长度加多了.有关double的确定也是一样:
</p><blockquote>

<ul>
<li>If bits is 0x7ff0000000000000L, the double value will be positive inﬁnity.
</li>
<li>If bits is 0xfff0000000000000L, the double value will be negative inﬁnity.
</li>
<li>If bits is in the range 0x7ff0000000000001L through 0x7fffffffffffffffL or in the range 0xfff0000000000001L through 0xffffffffffffffffL, the double value will be NaN.
</li>
<li>In all other cases, let s, e, and m be three values that might be computed from bits:
<ul>
<li>int s = ((bits &gt;&gt; 63) == 0) ? 1 : -1;
</li>
<li>int e = (int)((bits &gt;&gt; 52) &amp; 0x7ffL);
</li>
<li>long m = (e == 0) ?
        (bits &amp; 0xfffffffffffffL) &lt;&lt; 1 :
        (bits &amp; 0xfffffffffffffL) | 0x10000000000000L;
</li>
<li>Then the ﬂoating-point value equals the double value of the mathematical expression s*m*2<sup>(e-1075)</sup>
</li>
</ul>

</li>
</ul>



</blockquote>


</div>

</div>

<div id="outline-container-2-3-6" class="outline-4">
<h4 id="sec-2-3-6">CONSTANT_NameAndType_info</h4>
<div class="outline-text-4" id="text-2-3-6">




<pre class="example">CONSTANT_NameAndType_info {
  u1 tag;
  u2 name_index;
  u2 descriptor_index;
}
</pre>

<p>
index指向的都是 CONSTANT_Utf8_info,一个是名字,一个是 descriptor.
</p></div>

</div>

<div id="outline-container-2-3-7" class="outline-4">
<h4 id="sec-2-3-7">CONSTANT_Utf8_info</h4>
<div class="outline-text-4" id="text-2-3-7">

<blockquote>

<p>The CONSTANT_Utf8_info structure is used to represent constant string values.String content is encoded in <i>modified</i> UTF-8.
</p>
</blockquote>


<p>
和标准的UTF-8有小不同:
</p><blockquote>

<p>There are two differences between this format and the “standard” UTF-8 format.
First, the null character (char)0 is encoded using the 2-byte format rather than
the 1-byte format, so that modiﬁed UTF-8 strings never have embedded nulls.
Second, only the 1-byte, 2-byte, and 3-byte formats of standard UTF-8 are used.
The Java VM does not recognize the four-byte format of standard UTF-8; it uses
its own two-times-three-byte format instead.
</p>
</blockquote>


<p>
结构如下:
</p>


<pre class="example">CONSTANT_Utf8_info {
  u1 tag;
  u2 length;
  u1 bytes[length];
}
</pre>

<p>
没有可以多废话,很明显,限制条件是,不能是0 和 range(0xf0, 0xff)<sup><a class="footref" name="fnr-.4" href="#fn-.4">4</a></sup>
</p>
</div>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4">扯远了,要回来了,access_flags</h3>
<div class="outline-text-3" id="text-2-4">

<p>   列表就可以,如下:
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="right" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">Flag Name</td><td class="right">Value</td><td class="left">Intepretation</td></tr>
<tr><td class="left">ACC_PUBLIC</td><td class="right">0x0001</td><td class="left">Declared public; may be accessed from outside its package.</td></tr>
<tr><td class="left">ACC_FINAL</td><td class="right">0x0010</td><td class="left">Declared final; no subclasses allowed.</td></tr>
<tr><td class="left">ACC_SUPER</td><td class="right">0x0020</td><td class="left">Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr>
<tr><td class="left">ACC_INTERFACE</td><td class="right">0x0200</td><td class="left">Is an interface, not a class.</td></tr>
<tr><td class="left">ACC_ABSTRACT</td><td class="right">0x0400</td><td class="left">Declared abstract; must not be instantiated.</td></tr>
<tr><td class="left">ACC_SYNTHETIC</td><td class="right">0x1000</td><td class="left">Declared synthetic; Not present in the source code.</td></tr>
<tr><td class="left">ACC_ANNOTATION</td><td class="right">0x2000</td><td class="left">Declared as an annotation type.</td></tr>
<tr><td class="left">ACC_ENUM</td><td class="right">0x4000</td><td class="left">Declared as an enum type.</td></tr>
</tbody>
</table>

  看位置就可以知道,几个flag可以同时存在,interface必须也要有abstract,annotation有了就要有interface.

<p>
  super的用来向上兼容,新编译器都应该直接设置.应该是为了 invokespecial 这个指令.
</p>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5">this_index</h3>
<div class="outline-text-3" id="text-2-5">

<p>   指向pool里面的CONSTANT<sub>Class</sub><sub>info类型</sub>.
</p></div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6">super_class</h3>
<div class="outline-text-3" id="text-2-6">

<p>   除了object都要有,这是废话.不能是final的,这也是废话.interface的都要指向object,这个算不是废话.
</p></div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7">interfaces_count and interfaces[]</h3>
<div class="outline-text-3" id="text-2-7">

<p>   顺序是代码中的从左到右,或者是direct superinterface.指向的,自然是pool里面的东西.
</p></div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8">fields_count and fields[]</h3>
<div class="outline-text-3" id="text-2-8">

<p>   其中的field是field_info结构
</p>
</div>

<div id="outline-container-2-8-1" class="outline-4">
<h4 id="sec-2-8-1">field_info</h4>
<div class="outline-text-4" id="text-2-8-1">




<pre class="example">field_info {
 u2 access_flags;
 u2 name_index;
 u2 descriptor_index;
 u2 attributes_count;
 attribute_info attributes[attributes_count];
}
</pre>

<p>
主要就是 attribute_info ,结构:
</p>


<pre class="example">attribute_info {
  u2 attribute_name_index;
  u4 attribute_length;
  u1 info[attribute_length];
}
</pre>

<p>
有predefined的,SourceFile,ConstantValue,Code,StackMapTable,Exceptions,InnerClasses,EnclosingMethod, Synthetic, Signature,
LineNumberTable, LocalVariableTable and Deprecated&hellip;后面太多了,不看了.
</p></div>
</div>

</div>

<div id="outline-container-2-9" class="outline-3">
<h3 id="sec-2-9">method_count and methods[]</h3>
<div class="outline-text-3" id="text-2-9">

<p>   methods里面存了所有的方法,除了superclass和superinterface的方法.
</p></div>

</div>

<div id="outline-container-2-10" class="outline-3">
<h3 id="sec-2-10">attributes_count and attributes[]</h3>
<div class="outline-text-3" id="text-2-10">


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> 描述是什么东西?Doc?
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> 为什么double和long有特殊呢?
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.3" href="#fnr-.3">3</a></sup> 原来Java也是要传this的&hellip;&hellip;
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.4" href="#fnr-.4">4</a></sup> 这个区间到底是开是闭没说,估计应该是闭区间.
</p>


</div>
</div>
</div>

</div>
</div>
