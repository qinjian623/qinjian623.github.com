#+BEGIN_HTML
---
layout: post
title: Introduction for non-cs.
tags: [intro]
---
#+END_HTML

* 给非计算机专业的介绍性文章

** 简单说明:

本文的原文位置在
http://www.cl.cam.ac.uk/freshers/raspberrypi/tutorials/os/introduction.html 
作者发布的版权为[[http://creativecommons.org/licenses/by-sa/3.0/deed.en_GB][Creative Commons Attribution-ShareAlike 3.0 Unported
License]],本文同样以以上协议发布.


** 操作系统
操作系统是一种复杂的程序,用来管理一台计算机上的各个程序,比如说分配计算
机的CPU时间片[fn:14],内存资源,其他的硬件资源等等.主流的桌面操作系统一般包括
GNU/Linux[fn:3] [fn:7], Mac OS X[fn:4]和微软的Windows.其他的一些设备也是需要操
作系统的,比如手机就会使用Android[fn:5], iOS和Windows Phone这类的系
统.[fn:1] [fn:6]
由于操作系统直接与计算机的硬件交互,所以它需要知道具体硬件的一些信息.为了
方便操作系统可以广泛的应用在各种计算机上, *驱动* 的概念被引入.驱动的作用
就是为了使操作系统可以方便的与一个特定的硬件设备进行通讯, 它也是一段代码,但
是可以很容易的加入或者移出操作系统.

** 汇编代码
汇编代码的特点就是十分接近计算机硬件层,易于被机器所"理解"[fn:8].计算机的
工作是通过处理器和内存来实现的,处理器可以做一些数字的加减法这类的简单工
作,内存则负责存储这些数字.计算机通电后,处理器就通过执行程序员交给它的指
令来改变内存中的数字和与硬件交互.汇编代码就是这些指令被翻译成方便人类读
取的形式[fn:9].

一般编程,程序员都会使用一门编程语言,譬如C++,Java,C#,Basic等等.之后再调用
编译器将这些由程序员编写的代码翻译成为汇编代码,之后会再进一步翻译成为二
进制代码[fn:2].二进制代码是计算机实际能够理解的语言,只不过实在不适合人类
阅读[fn:10].汇编代码就相对易读,但是供程序员使用的指令也依然很少. 请谨记
每个使用汇编代码编写的指令,都是计算机可以直接理解的,因此这些指令是受下层
硬件决定的,每个指令都会被实际上的电路直接使用.

[图片占位符]

和一般的上层编程一样,汇编语言也有多种.当然,多样的原因不是像上层语言[fn:11]那样,
而是因为世界上存在多种不同的处理器[fn:12],每种处理器往往都设计成理解某一个语言.因
此,一个程序员如果用汇编语言给一个机器编写程序,那么不同类的机器就不能够使
用这一程序.一般而言,这种每个不同架构都需要重新编写程序的情况实在是个大灾
难[fn:13],不过对于操作系统来说,这就无所谓了,因为它本身就要为不同的硬件重新编写.不
过,不是操作系统的所有部分都需要重写,因为操作系统的大部分也是由c++或者c语
言这种上层语言来编写,以方便转化到不同的架构上,需要重写的只是那些必须通过
汇编语言来实现的部分.

目前,已经可以进入第一课时了.

** 再提几个人物:
图灵,wiki地
址:http://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5 
八卦点在于其男同性恋取向.09年,英国政府才对政府当年针对其同性恋的迫害道歉.提
出了图灵机.

约翰·冯·诺伊曼, wiki地
址:http://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC 
现代计算机组成结构的提出者.同时还对量子力学有重要贡献.(数学家真的是万能的)

阿隆佐·邱奇,wiki地址:
http://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87
图灵的导师,lambda演算的提出者,这一系统被证明和图灵机等价,函数式编程的基
础.

约翰·麦卡锡,wiki地址:
http://zh.wikipedia.org/wiki/%E7%BA%A6%E7%BF%B0%C2%B7%E9%BA%A6%E5%8D%A1%E9%94%A1
人工智能概念的提出者,函数式编程语言Lisp的发明人.LISP语言也是emacs编辑器
的配置语言.可以说是括号最多的一门语言.语法结构很像[[http://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85][逆波兰式]].

高德纳,wiki地址:
http://zh.wikipedia.org/wiki/%E9%AB%98%E5%BE%B7%E7%BA%B3
tex排版系统的作者,它的衍生版本如latex等被广泛应用于论文写作.Tex的bug奖励
规则和版本号也是很有意思.wiki上有说明.


注意以上的简历会发现,他们都被称为数学家,或者专业是数学专业.原因很简单,当
时还没有计算机这个专业,而计算机正是从数学发源而来.可以说是数学对人类影响
最直观的领域之一.貌似《逻辑的引擎》这本书对这方面的说明应该不错,不过我没
有读过,只在这里一提.

** 如何做研究
http://www.cs.indiana.edu/mit.research.how.to.html

来自MIT 人工智能实验室.
这篇文章年代陈旧.但是依然价如瑰宝.如果本科入学就能看到该文,一定受益匪浅.中文版也广泛分布了.Baidu即可.
不知道国内有没有学校的某个实验室能够有如此积累.

** 专业书本
   暂空
* Footnotes

[fn:1] 更完整的操作系统清单,请参考
  [[http://en.wikipedia.org/wiki/List_of_operating_systems][ List of operating systems - Wikipedia, the free encyclopedia]]

[fn:2] 在这里,对"一般编程"是简化了描述,事实上,它与语言和机器都息息相关,
深入了解,可以参考
[[http://en.wikipedia.org/wiki/Compiler][ Compiler - Wikipedia, the free encyclopedia]]

[fn:3] Linux受Minix影响,两者之间也是一段恩怨情仇,Linux的作者[[http://en.wikipedia.org/wiki/Linus_Torvalds][Linus]] 在开发
Linux初期,就是使用的Minix,其设计也受到了Minix很大影响,但是两者之间在宏内
核和微内核结构上的分歧,还引发了两个作者的一次论战,可以参考
[[http://en.wikipedia.org/wiki/Tanenbaum%E2%80%93Torvalds_debate][Tanenbaum–Torvalds debate]],当然两者的设计思想各有千秋,结合两者的优点在一
起往往是工程实践上的折中,Linux引入的内核模块设计,Windows NT内核则是所谓
的混合模式.如果想要学习下OS,minix显然是很好的选择,Minix的作者的
[[http://en.wikipedia.org/wiki/Andrew_S._Tanenbaum#Books][出版物]] 都是在CS上很重要和著名的,如操作系统和计算机网络相关的大部头.

[fn:4] Mac OS X与BSD系的系统也有一定的关系,具体可参看[[http://en.wikipedia.org/wiki/Mac_OS_X][wiki]],同时其内核
Darwin也是开源的.当然内核上层的软件没有开源.Mac OS X的图形界面(GUI)一直
被人称道,不过一直"为他人作嫁衣裳"的[[http://en.wikipedia.org/wiki/PARC_(company)][Xerox PARC]]对于GUI,对CS的多个重要领
域的"无私"贡献,实在是一部悲情剧,这个研究中心的历史和成果也值得八卦.

[fn:5] 对于Android,可以理解为Linux,其在Linux内核上层构建了一层接口,并且
提供了Dalvik这个虚拟机,其执行代码从Java的虚拟机执行码转化.因此Android的
持有者Google与Java当前的持有者Oracle有了关于Java的版权的诉讼.当然,Java其
实并不是Oracle发明,而是被Oracle收购的Sun公司推出,相比Oracle而言,或许Sun
公司更容易被人们称为"伟大",是的,伟大与否与公司成败没有什么必然联系.Sun公
司的历史同样值得一看,<浪潮之巅>这本书介绍了多个公司的历史.

[fn:6] unix-like的系统在CS历史上的地位难以撼动,其发展史也是CS这门学科应
用于人类社会的一个缩影,这篇[[http://coolshell.cn/articles/2322.html][文章]] 对unix的历史有介绍,并不涉及技术,即使文科背景都可以理解.
稍微涉及一点技术的介绍<unix编程艺术>很精彩.其作者Eric S. Raymond出版物都丰富多彩,比如:
学会如何问问题:http://www.catb.org/~esr/faqs/smart-questions.html ,无论
是否技术人员,都值得一看.
如何成为黑客:http://www.catb.org/esr/faqs/hacker-howto.html

还有大教堂与集市等等,他的黑客五部曲(包括《黑客道简史》、《大教堂和集市》、
《如何成为一名黑客》、《开拓智域》、《魔法大锅炉》)闻名于世,[[http://master-zhdoc.googlecode.com/files/ericraymondfive-0.8.0.pdf][中文版本]] 不
是最新版本,但无碍阅读. 有关hacker(黑客)和cracker(骇客)的区别,可以交给Baidu.
另外<黑客与画家>及其作者,都值得一看.

unix最初的两位作者Ken Thompson 和 Dennis Ritchie也同时是c语言的创造
者.Ritchie在2011.10.12被发现逝世,具体时间未知(因为他一直单身),在Steve
Jobs逝世之后一周.但其贡献只会在Jobs之上而不会在Jobs之下.
产生unix的贝尔实验室在之后也在考虑unix的继承者,比如说
Plan9,http://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs 是wiki地址.看到
该计划的吉祥物一定能够萌翻你.如果是Google的爱好者的话,会发现这个萌物竟然
和Google GO语言的吉祥物十分接近,话说Go语言的作者也有Ken Thompson.


[fn:7] 有关GNU/Linux的名称也稍有讲究,GNU项目和Linux项目没有必然的联系,GNU是
Richard Matthew Stallman(RMS)发起的一个项目,作为开放源码运动的重要一部分.提到
RMS往往会联想到另外两个事物,GNU Emacs和MIT的人工智能实验室.Emacs作为"神的编辑
器",其被大量广泛的应用,即使是非CS专业的人,譬如有代表性的文章
http://www.gtdstudy.com/?p=2634 .当然,存在Emacs的地方是不能没有"编辑器之
神"的Vim的.两者论战已经连绵N年,而两者最初始版本都比大部分renren用户的年
纪大.Google "editor war"即可,当然,这里说的是Google而不是Baidu.在这一论战
上的恶搞更是层出不穷.是的,在CS领域里,自由精神熠熠生辉.恶搞正是其体现之
一.GNU项目中著名的软件譬如gdb\gcc对整个计算机领域的影响是难以想象的.所以
去他的官方网站逛一圈还是值得的,网址:http://www.gnu.org .MIT人工智能实验
室则与黑客的诞生相关,之后会提到的Eric S.Raymond的五部曲中就有黑客历史介绍.


[fn:8] 计算机不能够理解任何东西,起码到目前为止.包括siri,也不能够
理解任何东西.但是,到目前为止计算机领域在人工智能上的发展仍然创造了巨大
价值,比如,最近的Google的自动驾驶汽车,已经行驶到万公里级别仍然没有出现
过交通意外,当然,价值不菲.装自动驾驶系统的价格能赶上一辆豪车了.不过技术的
进步是超乎人类想象的.特别是在计算机硬件的成本上,想想几年前硬盘和内存
的价格就知道了.在计算机芯片上就存在[[http://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B][摩尔定律]], 到目前为止,相同价格上,电
脑性能每18个月就会翻一翻.我们可以对比下改革开放后的中国经济发展速度,就
知道这一增长的力量.回到人工智能,其中的机器学习就能够利用统计规律分析现有的历史数据,
获得对新数据的处理能力,而其中的数学原理却并不复杂.具有一般工学数学背景
的都可以看下科普级的书本<数学之美>,介绍了领域中的一部分内容.想要深入,斯坦福的公
开课程<机器学习>在网易公开课上有中文翻译版.机器学习也不仅仅包括利用统计方法.
或者Coursera公开课内的相关课
程. https://www.coursera.org/course/neuralnets 和
https://www.coursera.org/course/ml

[fn:9] 汇编语言基本与机器指令一一对应.所以基本每个写下的指令,机器都会
照例执行.相比上层语言编写的程序,性能和文件大小上都有很大的优势.在某些
情况下会有数量级的提升.因此在一些对性能要求较高的功能上,会有使用汇编代
码的编写的情况.也即,上层语言和低层语言混用.没错,程序语言经常会有混用的
情况发生,一个程序并不一定只包涵一种语言.有些"无聊"的人会比赛看谁的一个
程序中混用的语言最多.说到这里,还有一个更加"无聊"的比赛,看谁的代码写的
最难看, [[http://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85C%E8%AF%AD%E8%A8%80%E6%B7%B7%E4%B9%B1%E4%BB%A3%E7%A0%81%E5%A4%A7%E8%B5%9B][国际C语言混乱代码大赛]] 可以让有c语言基础的大饱眼福.计算机语言和
人类语言类似,可以把每个程序员看做写作文的.如果是命题作文的话,不同人写
出来的自然也不同,有的人文字简练,有的人段落清晰,有的人辞藻华美.同样对于
程序员也一样.而且还有不同的语言之分,譬如人类社会中英语\中文\法文等等.这
也是Editor War之外的一个热核战场.所以如果自己觉得心情太好的话,可以在技
术主题的论坛或者网络社区上,大吼一声"XX编辑器/语言最NB,其他的都是一坨屎
".事实上不同的语言都有各自的特征,如同正常人一样,精通母语和第一外语,然
后了解其他更多的语言是最好的.因为语言可以很好开拓人的视野,学会一门,往
往就打开了新的一扇门,这扇门并不能通往财富\名誉,只是通往另外的一个未知
世界,最终都是通往你自己的内心.

[fn:10] 二进制代码真的是这样的"0101010110100010111101011101",当然别指望
直接用记事本打开会是这样.因为这里你看到的一个0/1其实代表的是8个机器码的
01.即使是最基本的文本文件都是被编码解码后展现给人类的.最简单的文本编码是
ASCII编码,历史可以参见http://en.wikipedia.org/wiki/ASCII ,不能支持中文,
中文的编码有很多比如GBK/GB2312/UTF等等,两岸三地的编码加起来能让人眼花缭
乱,utf-8因为通用且可以描述所有的语言字符,包括中文,正在被越来越广泛的应用.说到utf-8,
其作者之一就是unix的作者之一Ken Thompson.编解码在通讯专业一定会接触很多,
在计算机中很多也涉及编解码问题,"语音识别","自然语言处理","头像识别"都可
以认为是一种编解码.当然,密码破解也是如此.学习<信息论>这门课应该可以对编
码相关有一些了解.

[fn:11] 也有叫做高级语言和低级语言的.不过考虑到"高级"可能会给人们带来
错觉:"高级"语言一定比"低级"语言好,事实情况是,在不同的应用背景下,上层语言
和底层语言会有不同的优势和劣势,纯粹单一的看待一门语言比另外一门好/优秀,
是没有意义的.即使在某些已经死亡的语言上,也会有值得借鉴的地方.这其实在现
实中是经常出现的,对于某项事物,我们不能简单的以一个指标直接评价,如何结合
应用场景扬长避短往往是一门艺术.

[fn:12] 最广为人知的就是intel的产品,然后就是AMD的处理器.而在这之外还有很
多应用广泛但是人们并没有意识到其存在.比如ARM架构的处理器,目前几乎所有的
智能手机使用的都是ARM架构的处理器.其实intel和AMD的处理器产品属于同一架构,x86或
者是x86-64位,也因此,运行在这两者产品上的软件是互相兼容的,从来不会有谁会
碰到"xx软件for intel cpu","xx软件 for amd cpu",相同cpu架构上的程序都是可
以互相兼容的.而ARM架构的设计公司不同于intel/amd的是它只是负责设计cpu架构而不
自己生产,生产商有兴趣的,可以购买架构的授权,[[http://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B#ARM_.E5.85.A7.E6.A0.B8.E7.9A.84.E6.8E.88.E6.AC.8A.E8.88.87.E6.87.89.E7.94.A8][wiki]] 有介绍,智能手机上基本使
用的都是ARM架构,比如iphone/ipad,绝大部分的Android产品.MIPS架构也不能忘记
提下,因为中国的"龙芯"使用的就是MIPS的架构.

[fn:13]这里就体现了上层语言的优势.由于上层语言更加集中于程序设计的逻辑,
而不是具体的硬件等等,编写程序的人可以更好的设计程序结构,减少不必要的时间
耗费,提高编写程序的速度.一些接近下层的编译型的上层语言(比较拗口,因为上层语言也有更上层的和相对下层的)在编写完成后,会通过编译器汇编器
的一系列工作将程序的源代码翻译成为机器代码,而汇编语言其实是机器二进制码
的助记符形式.整个过程可以理解为 上层语言代码 -> 汇编语言代码 -> 二进制代
码.我们称呼其为上层语言,就因为这如同一层层的夹心饼干.居于上层的自然叫做
上层.在计算机里,分层的思想被广泛应用,在硬件上缓冲区的分层,在软件上TCP/IP
协议的分层.以及更广泛发生的上层语言的分层,语言可能不是简单像三层语言那样,可能
更多层次,特别是有些解释性语言,并不是直接翻译成为二进制码,而是由解释器将
其翻译成为某一种中间层的语言,这些语言再进一步执行,而执行可能是发生在某一个高
于机器二进制码层上.而这一层可能和机器二进制码又有多层的隔离.当然,最终的
执行都必须在二进制码层上,因为目前的计算机不懂任何其他的层. 分层基本是计
算机的万金油解法,被广泛应用,有人说过大意如此"如果有个问题没法解决,就加个
抽象层吧".但是分层也有缺点,最明显的就是速度会变慢,<盗梦空间>是个很不错的
体现.在硬件的分层上,有一张最直观的图片,<深入理解计算机系统>封面上的
那幅图就是计算机的存储系统的分层的明显展示. 

[fn:14] CPU时间片是用来分配程序执行时间的基本单位,对于一个简化后的CPU来说,程序是
不能够并行执行的,一次只能执行一个,如果同时运行多个程序,程序共用一个CPU,
只能在一段时间里执行一个程序,多个程序就会排队等待,结束这段时间片后会再交
给别的程序来执行.之所以平时使用上感觉是多个程序同时执行,那是因为这个时间
片很短,人类感觉不出来而已,就像电影和动画的原理一样,每秒24帧就能让你感觉
是连续的了.目前个人电脑也都属于多核CPU,在这种情况下,就可以在不同的CPU核
心上同时执行多个程序了.对于操作系统来说,对时间片的分配存在"抢占式"和"非
抢占式",抢占式是在一个程序占用太多时间后,操作系统会强行收回CPU,分
配给下一个程序.非抢占式是更多的交给程序来决定是否执行完毕可以交出CPU.目
前PC上的操作系统一般都是抢占式,因为非抢占式可能会造成一个程序占用过多
CPU时间,其他程序就没法执行,给人的感觉就是别的程序死掉了.
